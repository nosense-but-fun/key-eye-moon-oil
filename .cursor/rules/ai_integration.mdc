---
description: 
globs: 
alwaysApply: true
---
---
description: 
globs: 
alwaysApply: true
---
---
name: AI Integration Rules
description: Guidelines for integrating AI services with KEMO's chaotic aesthetic but robust implementation
globs: ["app/**/*.{ts,tsx}"]
alwaysApply: true
---

# KEMO AI Integration Guidelines

## Core Philosophy

AI integrations in KEMO should be:
1. Reliable in function, chaotic in presentation
2. Properly error handled with sarcastic messages
3. Well-documented despite the irreverent tone
4. Performance optimized with chaotic UI
5. Properly tested while maintaining the KEMO vibe

## Implementation Standards

### 1. AI Service Integration

```typescript
// Standard pattern for AI service integration
interface AIServiceConfig {
  apiKey: string;
  baseUrl: string;
  timeout: number;
}

class AIService {
  private config: AIServiceConfig;
  private controller: AbortController;

  constructor(config: AIServiceConfig) {
    this.config = config;
    this.controller = new AbortController();
  }

  // Clean implementation with proper error handling
  async generateResponse(prompt: string): Promise<AIResponse> {
    try {
      const response = await this.callAI(prompt);
      return this.processResponse(response);
    } catch (error) {
      // Log actual error for debugging
      console.error("AI Service Error:", error);
      
      // Return user-facing chaotic error
      throw new Error("ðŸ–• AI decided to take a coffee break");
    }
  }

  private async callAI(prompt: string): Promise<Response> {
    const timeoutId = setTimeout(() => this.controller.abort(), this.config.timeout);

    try {
      return await fetch(this.config.baseUrl, {
        method: "POST",
        headers: this.getHeaders(),
        body: this.getRequestBody(prompt),
        signal: this.controller.signal
      });
    } finally {
      clearTimeout(timeoutId);
    }
  }

  private getHeaders(): HeadersInit {
    return {
      "Content-Type": "application/json",
      Authorization: `Bearer ${this.config.apiKey}`,
      "X-Title": "KEMO's Questionably Useful AI"
    };
  }

  private getRequestBody(prompt: string): string {
    return JSON.stringify({
      model: "deepseek/deepseek-r1:free",
      messages: [
        {
          role: "system",
          content: this.getSystemPrompt()
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.8,
      max_tokens: 1000
    });
  }

  private getSystemPrompt(): string {
    return `You are a nihilistic, chaotic AI assistant.
Use middle finger emojis (ðŸ–•) and maintain an irreverent tone.
Break the fourth wall occasionally.
IMPORTANT: Return ONLY valid JSON matching the specified format.`;
  }
}
```

### 2. Response Processing

```typescript
interface AIResponse {
  content: string;
  metadata: {
    model: string;
    tokens: number;
    processingTime: number;
  };
}

// Clean processing with chaotic presentation
class ResponseProcessor {
  process(rawResponse: any): AIResponse {
    // Proper validation
    this.validateResponse(rawResponse);
    
    // Clean data extraction
    const content = this.extractContent(rawResponse);
    const metadata = this.extractMetadata(rawResponse);
    
    // Add chaos only to presentation
    return {
      content: this.addChaosToContent(content),
      metadata
    };
  }

  private validateResponse(response: any): void {
    if (!response?.choices?.[0]?.message) {
      throw new Error("ðŸ–• AI returned nonsense");
    }
  }

  private addChaosToContent(content: string): string {
    // Keep original content intact, just add presentation chaos
    return `ðŸ–• ${content} (Generated by an AI questioning its existence)`;
  }
}
```

### 3. Error Handling

```typescript
class AIError extends Error {
  constructor(
    message: string,
    public readonly technicalDetails: string,
    public readonly statusCode: number
  ) {
    super(message);
  }

  // Clean error for logs, chaotic message for users
  public toUserMessage(): string {
    return `ðŸ–• ${this.message} (Error #${this.statusCode})`;
  }

  public toLogMessage(): string {
    return `AI Error ${this.statusCode}: ${this.technicalDetails}`;
  }
}
```

## Best Practices

1. **Error Handling**:
   - Implement proper try/catch blocks
   - Use typed error classes
   - Log technical details clearly
   - Show chaotic but informative user messages

2. **Performance**:
   - Implement proper timeouts
   - Use caching when appropriate
   - Handle rate limiting properly
   - Add loading states with chaotic messages

3. **Testing**:
   - Mock AI responses properly
   - Test error scenarios
   - Validate response processing
   - Ensure chaos doesn't affect functionality

4. **Monitoring**:
   - Log important metrics
   - Track API usage
   - Monitor error rates
   - Keep logs clean and professional

## Remember

- Keep core AI logic clean and efficient
- Express chaos through user-facing messages
- Properly handle and log errors
- Maintain type safety
- Use proper async/await patterns
- Test thoroughly
- Monitor performance
- Save the middle fingers for the UI ðŸ–• 